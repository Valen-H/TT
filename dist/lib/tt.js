"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tt = void 0;
var tt;
(function (tt) {
    let Act;
    (function (Act) {
        Act[Act["STOP"] = 1] = "STOP";
        Act[Act["CONT"] = 2] = "CONT";
        Act[Act["UNREG"] = 4] = "UNREG";
        Act[Act["PASS"] = 8] = "PASS";
    })(Act = tt.Act || (tt.Act = {}));
    class Pattern extends RegExp {
        pattern;
        cb = (t, str, i) => Act.CONT;
        constructor(pattern, cb) {
            super(pattern);
            let flags = "i";
            if (pattern instanceof Pattern)
                cb = pattern.cb;
            if (pattern instanceof RegExp) {
                flags = pattern.flags;
                pattern = pattern.source;
            }
            if (typeof pattern == "string")
                pattern = new RegExp(pattern, flags);
            if (cb instanceof Function)
                this.cb = cb;
            else if (cb)
                throw "Bad Callback";
            this.pattern = pattern;
        } //ctor
        get flags() {
            return this.pattern.flags;
        } //g-flags
        get source() {
            return this.pattern.source;
        } //g-source
        try(str, i = -1) {
            if (this.pattern.test(str))
                return this.cb(this, str, i) || Act.CONT;
            return Act.PASS;
        } //test
        [Symbol.match](str) {
            return str.match(this.pattern) || [];
        }
        [Symbol.matchAll](str) {
            return str.matchAll(this.pattern);
        }
        static get [Symbol.species]() {
            return RegExp;
        }
    } //Pattern
    tt.Pattern = Pattern;
    class TT {
        patterns;
        constructor(patterns = []) {
            if (patterns instanceof Array)
                this.patterns = patterns.map((p) => new Pattern(p));
            else
                throw "Bad Patterns";
        } //ctor
        test(str) {
            let ret = false;
            for (let i = 0; i < this.patterns.length; i++) {
                const p = this.patterns[i], po = p.try(str, i);
                if ((po & Act.UNREG) == Act.UNREG) {
                    this.unreg(i--);
                    ret = true;
                }
                if ((po & Act.STOP) == Act.STOP)
                    return true;
                if ((po & Act.CONT) == Act.CONT)
                    ret = true;
            }
            return ret;
        } //test
        reg(pat, idx, rep = 0) {
            let opat;
            if (pat instanceof Array)
                opat = pat.map((p) => new Pattern(p));
            else
                opat = new Pattern(pat);
            if (opat instanceof Array) {
                if (idx && idx >= 0)
                    this.patterns.splice(idx, rep, ...opat);
                else {
                    while (rep--)
                        this.patterns.pop();
                    this.patterns.push(...opat);
                }
            }
            else {
                if (idx && idx >= 0)
                    this.patterns.splice(idx, rep, opat);
                else {
                    while (rep--)
                        this.patterns.pop();
                    this.patterns.push(opat);
                }
            }
            return opat;
        } //reg
        unreg(pat) {
            let pats = [];
            if (typeof pat == "undefined")
                return this.patterns.splice(0, this.patterns.length);
            else if (pat instanceof Array) {
                let remn = 0;
                pat.sort((a, b) => {
                    if (a instanceof Pattern)
                        return 1;
                    else if (b instanceof Pattern)
                        return -1;
                    else
                        return a - b;
                }).forEach((p) => {
                    const idx = p instanceof Pattern ? this.patterns.findIndex((pp) => pp == p) : (p - remn);
                    if (idx >= 0)
                        pats.push(...this.patterns.splice(idx, 1));
                    if (typeof p == "number")
                        remn++;
                });
            }
            else {
                const idx = pat instanceof Pattern ? this.patterns.findIndex((pp) => pp == pat) : pat;
                if (idx >= 0)
                    pats.push(...this.patterns.splice(idx, 1));
            }
            return pats;
        } //unreg
        get [Symbol.isConcatSpreadable]() {
            return true;
        }
        *[Symbol.iterator]() {
            yield* this.patterns;
        }
    } //TT
    tt.TT = TT;
})(tt = exports.tt || (exports.tt = {})); //tt
exports.default = tt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDOzs7QUFFYixJQUFjLEVBQUUsQ0FpSmY7QUFqSkQsV0FBYyxFQUFFO0lBRWYsSUFBWSxHQUtYO0lBTEQsV0FBWSxHQUFHO1FBQ2QsNkJBQVEsQ0FBQTtRQUNSLDZCQUFRLENBQUE7UUFDUiwrQkFBUyxDQUFBO1FBQ1QsNkJBQVEsQ0FBQTtJQUNULENBQUMsRUFMVyxHQUFHLEdBQUgsTUFBRyxLQUFILE1BQUcsUUFLZDtJQUlELE1BQWEsT0FBUSxTQUFRLE1BQU07UUFFM0IsT0FBTyxDQUFTO1FBQ2hCLEVBQUUsR0FBc0MsQ0FBQyxDQUFVLEVBQUUsR0FBVyxFQUFFLENBQVUsRUFBTyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztRQUV0RyxZQUFZLE9BQWtDLEVBQUUsRUFBc0M7WUFDckYsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRWYsSUFBSSxLQUFLLEdBQVcsR0FBRyxDQUFDO1lBRXhCLElBQUksT0FBTyxZQUFZLE9BQU87Z0JBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDaEQsSUFBSSxPQUFPLFlBQVksTUFBTSxFQUFFO2dCQUM5QixLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztnQkFDdEIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7YUFDekI7WUFDRCxJQUFJLE9BQU8sT0FBTyxJQUFJLFFBQVE7Z0JBQUUsT0FBTyxHQUFHLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUdyRSxJQUFJLEVBQUUsWUFBWSxRQUFRO2dCQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO2lCQUNwQyxJQUFJLEVBQUU7Z0JBQUUsTUFBTSxjQUFjLENBQUM7WUFFbEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFD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QixDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1FBQ2IsQ0FBQztRQUNELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1lBQ2pCLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdEIsQ0FBQztLQUVELENBQUMsSUFBSTtJQWpGTyxLQUFFLEtBaUZkLENBQUE7QUFFRixDQUFDLEVBakphLEVBQUUsR0FBRixVQUFFLEtBQUYsVUFBRSxRQWlKZixDQUFDLElBQUk7QUFFTixrQkFBZSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmV4cG9ydCBtb2R1bGUgdHQge1xyXG5cdFxyXG5cdGV4cG9ydCBlbnVtIEFjdCB7XHJcblx0XHRTVE9QID0gMSxcclxuXHRcdENPTlQgPSAyLFxyXG5cdFx0VU5SRUcgPSA0LFxyXG5cdFx0UEFTUyA9IDgsXHJcblx0fVxyXG5cdFxyXG5cdGV4cG9ydCB0eXBlIENhbGxiYWNrPFQsIFMgPSBhbnksIFUgPSBTPiA9ICh0OiBULCBzOiBTLCB1OiBVKSA9PiBBY3Q7XHJcblx0XHJcblx0ZXhwb3J0IGNsYXNzIFBhdHRlcm4gZXh0ZW5kcyBSZWdFeHAge1xyXG5cdFx0XHJcblx0XHRwdWJsaWMgcGF0dGVybjogUmVnRXhwO1xyXG5cdFx0cHVibGljIGNiOiBDYWxsYmFjazxQYXR0ZXJuLCBzdHJpbmcsIG51bWJlcj4gPSAodDogUGF0dGVybiwgc3RyOiBzdHJpbmcsIGk/OiBudW1iZXIpOiBBY3QgPT4gQWN0LkNPTlQ7XHJcblx0XHRcclxuXHRcdGNvbnN0cnVjdG9yKHBhdHRlcm46IFBhdHRlcm4gfCBSZWdFeHAgfCBzdHJpbmcsIGNiPzogQ2FsbGJhY2s8UGF0dGVybiwgc3RyaW5nLCBudW1iZXI+KSB7XHJcblx0XHRcdHN1cGVyKHBhdHRlcm4pO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGZsYWdzOiBzdHJpbmcgPSBcImlcIjtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUGF0dGVybikgY2IgPSBwYXR0ZXJuLmNiO1xyXG5cdFx0XHRpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG5cdFx0XHRcdGZsYWdzXHQ9IHBhdHRlcm4uZmxhZ3M7XHJcblx0XHRcdFx0cGF0dGVyblx0PSBwYXR0ZXJuLnNvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdGlmIChjYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB0aGlzLmNiID0gY2I7XHJcblx0XHRcdGVsc2UgaWYgKGNiKSB0aHJvdyBcIkJhZCBDYWxsYmFja1wiO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcclxuXHRcdH0gLy9jdG9yXHJcblx0XHRcclxuXHRcdGdldCBmbGFncygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5wYXR0ZXJuLmZsYWdzO1xyXG5cdFx0fSAvL2ctZmxhZ3NcclxuXHRcdGdldCBzb3VyY2UoKTogc3RyaW5nIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucGF0dGVybi5zb3VyY2U7XHJcblx0XHR9IC8vZy1zb3VyY2VcclxuXHRcdFxyXG5cdFx0dHJ5KHN0cjogc3RyaW5nLCBpOiBudW1iZXIgPSAtMSk6IEFjdCB7XHJcblx0XHRcdGlmICh0aGlzLnBhdHRlcm4udGVzdChzdHIpKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmNiKHRoaXMsIHN0ciwgaSkgfHwgQWN0LkNPTlQ7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gQWN0LlBBU1M7XHJcblx0XHR9IC8vdGVzdFxyXG5cdFx0XHJcblx0XHRbU3ltYm9sLm1hdGNoXShzdHI6IHN0cmluZyk6IFJlZ0V4cE1hdGNoQXJyYXkge1xyXG5cdFx0XHRyZXR1cm4gc3RyLm1hdGNoKHRoaXMucGF0dGVybikgfHwgWyBdO1xyXG5cdFx0fVxyXG5cdFx0W1N5bWJvbC5tYXRjaEFsbF0oc3RyOiBzdHJpbmcpOiBJdGVyYWJsZUl0ZXJhdG9yPFJlZ0V4cE1hdGNoQXJyYXk+IHtcclxuXHRcdFx0cmV0dXJuIHN0ci5tYXRjaEFsbCh0aGlzLnBhdHRlcm4pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XHJcblx0XHRcdHJldHVybiBSZWdFeHA7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9IC8vUGF0dGVyblxyXG5cdFxyXG5cdGV4cG9ydCBjbGFzcyBUVCB7XHJcblx0XHRcclxuXHRcdHB1YmxpYyBwYXR0ZXJuczogUGF0dGVybltdO1xyXG5cdFx0XHJcblx0XHRjb25zdHJ1Y3RvcihwYXR0ZXJuczogUGF0dGVybltdIHwgUmVnRXhwW10gfCBzdHJpbmdbXSA9IFsgXSkge1xyXG5cdFx0XHRpZiAocGF0dGVybnMgaW5zdGFuY2VvZiBBcnJheSkgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLm1hcCgocDogUGF0dGVybiB8IFJlZ0V4cCB8IHN0cmluZyk6IFBhdHRlcm4gPT4gbmV3IFBhdHRlcm4ocCkpO1xyXG5cdFx0XHRlbHNlIHRocm93IFwiQmFkIFBhdHRlcm5zXCI7XHJcblx0XHR9IC8vY3RvclxyXG5cdFx0XHJcblx0XHR0ZXN0KHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRcdGxldCByZXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdFx0XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3QgcDogUGF0dGVybiA9IHRoaXMucGF0dGVybnNbaV0sXHJcblx0XHRcdFx0XHRwbzogQWN0ID0gcC50cnkoc3RyLCBpKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoKHBvICYgQWN0LlVOUkVHKSA9PSBBY3QuVU5SRUcpXHR7IHRoaXMudW5yZWcoaS0tKTsgcmV0ID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdGlmICgocG8gJiBBY3QuU1RPUCkgPT0gQWN0LlNUT1ApXHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRpZiAoKHBvICYgQWN0LkNPTlQpID09IEFjdC5DT05UKVx0cmV0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIHJldDtcclxuXHRcdH0gLy90ZXN0XHJcblx0XHRcclxuXHRcdHJlZyhwYXQ6IFBhdHRlcm5bXSB8IFJlZ0V4cFtdIHwgc3RyaW5nW10gfCBQYXR0ZXJuIHwgUmVnRXhwIHwgc3RyaW5nLCBpZHg/OiBudW1iZXIsIHJlcDogbnVtYmVyID0gMCk6IFBhdHRlcm4gfCBQYXR0ZXJuW10ge1xyXG5cdFx0XHRsZXQgb3BhdDogUGF0dGVybiB8IFBhdHRlcm5bXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChwYXQgaW5zdGFuY2VvZiBBcnJheSkgb3BhdCA9IHBhdC5tYXAoKHA6IFBhdHRlcm4gfCBSZWdFeHAgfCBzdHJpbmcpOiBQYXR0ZXJuID0+IG5ldyBQYXR0ZXJuKHApKTtcclxuXHRcdFx0ZWxzZSBvcGF0ID0gbmV3IFBhdHRlcm4ocGF0KTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChvcGF0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0XHRpZiAoaWR4ICYmIGlkeCA+PSAwKSB0aGlzLnBhdHRlcm5zLnNwbGljZShpZHgsIHJlcCwgLi4ub3BhdCk7XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR3aGlsZSAocmVwLS0pIHRoaXMucGF0dGVybnMucG9wKCk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdHRoaXMucGF0dGVybnMucHVzaCguLi5vcGF0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlkeCAmJiBpZHggPj0gMCkgdGhpcy5wYXR0ZXJucy5zcGxpY2UoaWR4LCByZXAsIG9wYXQpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0d2hpbGUgKHJlcC0tKSB0aGlzLnBhdHRlcm5zLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHR0aGlzLnBhdHRlcm5zLnB1c2gob3BhdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gb3BhdDtcclxuXHRcdH0gLy9yZWdcclxuXHRcdHVucmVnKHBhdD86IFBhdHRlcm5bXSB8IG51bWJlcltdIHwgUGF0dGVybiB8IG51bWJlcik6IFBhdHRlcm5bXSB7XHJcblx0XHRcdGxldCBwYXRzOiBQYXR0ZXJuW10gPSBbIF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAodHlwZW9mIHBhdCA9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdGhpcy5wYXR0ZXJucy5zcGxpY2UoMCwgdGhpcy5wYXR0ZXJucy5sZW5ndGgpO1xyXG5cdFx0XHRlbHNlIGlmIChwYXQgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHRcdGxldCByZW1uOiBudW1iZXIgPSAwO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHBhdC5zb3J0KChhOiBQYXR0ZXJuIHwgbnVtYmVyLCBiOiBQYXR0ZXJuIHwgbnVtYmVyKTogbnVtYmVyID0+IHtcclxuXHRcdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgUGF0dGVybikgcmV0dXJuIDE7XHJcblx0XHRcdFx0XHRlbHNlIGlmIChiIGluc3RhbmNlb2YgUGF0dGVybikgcmV0dXJuIC0xO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gYSAtIGI7XHJcblx0XHRcdFx0fSkuZm9yRWFjaCgocDogUGF0dGVybiB8IG51bWJlcik6IHZvaWQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgaWR4OiBudW1iZXIgPSBwIGluc3RhbmNlb2YgUGF0dGVybiA/IHRoaXMucGF0dGVybnMuZmluZEluZGV4KChwcDogUGF0dGVybik6IGJvb2xlYW4gPT4gcHAgPT0gcCkgOiAocCAtIHJlbW4pO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZiAoaWR4ID49IDApIHBhdHMucHVzaCguLi50aGlzLnBhdHRlcm5zLnNwbGljZShpZHgsIDEpKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKSByZW1uKys7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgaWR4OiBudW1iZXIgPSBwYXQgaW5zdGFuY2VvZiBQYXR0ZXJuID8gdGhpcy5wYXR0ZXJucy5maW5kSW5kZXgoKHBwOiBQYXR0ZXJuKTogYm9vbGVhbiA9PiBwcCA9PSBwYXQpIDogcGF0O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChpZHggPj0gMCkgcGF0cy5wdXNoKC4uLnRoaXMucGF0dGVybnMuc3BsaWNlKGlkeCwgMSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gcGF0cztcclxuXHRcdH0gLy91bnJlZ1xyXG5cdFx0XHJcblx0XHRnZXQgW1N5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVdKCk6IGJvb2xlYW4ge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuXHRcdFx0eWllbGQqIHRoaXMucGF0dGVybnM7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9IC8vVFRcclxuXHRcclxufSAvL3R0XHJcblxyXG5leHBvcnQgZGVmYXVsdCB0dDtcclxuIl19